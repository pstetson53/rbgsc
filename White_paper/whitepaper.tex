\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{enumitem}
\usepackage{hyperref}

\title{Refinement-Based Game Semantics with Concurrency\\A Fork of \texttt{rbgs}}
\author{R. Philip Stetson IV}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
The goal of this fork is to extend refinement-based game semantics (RBGS) with cooperative concurrency in a way that remains compositional and proof-oriented. Building on the three-dimensional refinement algebra of Zhang et al.~\cite{compcertoe}, the cooperative threading discipline of Zhang et al.~\cite{compcertoc}, and the compositional linearizability perspective of Vale et al.~\cite{ctlinear}, we add: (i) a concurrency effect signature, free monad, and Rocq-friendly notation; (ii) a handler- and scheduler-parametric operational semantics over configurations; and (iii) a reachability-based refinement predicate and small driver lemmas. The intent is to expose precise interfaces (signatures, handlers, schedulers) that can be tightened into full refinement proofs and case studies.
\end{abstract}

\section{Problem}
RBGS models programs as strategies over effect signatures with refinement conventions that compose along modules, abstraction levels, and state components~\cite{compcertoe}. The missing piece is a \emph{cooperative concurrency} layer—spawn, yield, send/recv, join—that:
\begin{itemize}[leftmargin=1.5em]
  \item respects the categorical structure already present (polynomial signatures, free monads, symmetric monoidal products);
  \item exposes scheduler and memory relations (e.g., TKMR~\cite{compcertoc}) as parameters rather than hard-wiring an operational model; and
  \item supports compositional refinement in the spirit of three-dimensional algebra while remaining compatible with compositional linearizability~\cite{ctlinear}.
\end{itemize}

\section{Approach}
\paragraph{Effect signature and monad.} We introduce a concurrency effect signature
\[
 \mathsf{Conc}(X) ::= \textsf{spawn}:X_{\mathsf{tid}} \mid \textsf{yield}:1 \mid \textsf{send}:\mathsf{Chan}\times\mathsf{Val}\to 1 \mid \textsf{recv}:\mathsf{Chan}\to\mathsf{Val} \mid \textsf{join}:\mathsf{Tid}\to\mathsf{Val},
\]
implemented as a dependent type and converted to a polynomial signature \(\Sigma_{\mathsf{Conc}}\). The free monad \(T_{\mathsf{Conc}}\) (module \texttt{ConcMonad}) provides \(\eta\), \(\mu\), and a tensor \(m_{X,Y}:T_{\mathsf{Conc}}X\times T_{\mathsf{Conc}}Y\to T_{\mathsf{Conc}}(X\times Y)\) that currently sequences then pairs results (a conservative, compositional default awaiting richer interleavings). Smart constructors (\texttt{spawn}, \texttt{yield}, \texttt{send}, \texttt{recv}, \texttt{join}) and a light \texttt{do}-notation keep scripts concise.

\paragraph{Configurations, handlers, and scheduler.} A configuration (\texttt{ConcStrategy}) is a list of thread states plus shared state; shared-state merge is abstracted as a binary operator. Handlers interpret \(\textsf{spawn}/\textsf{yield}/\textsf{send}/\textsf{recv}/\textsf{join}\) against shared state and optionally add runnable threads. A scheduler \(\sigma : C \to \mathsf{option}\,\mathbb{N}\) selects a runnable thread. The small-step relation
\[
  c \xrightarrow{\sigma,h,t} c'
\]
is defined by interpreting the selected thread through \(T_{\mathsf{Conc}}\), applying handlers, updating the chosen thread, and appending any spawned threads.

\paragraph{Refinement.} The refinement predicate (\texttt{ConcRefinement}) relates an abstract term \(t : T_{\mathsf{Conc}}\,C\) to a concrete configuration \(c\) by reachability:
\[
  R_{\mathsf{conc}}(t,c) \;:\iff\; \exists c_0.\; t = \eta\,c_0 \;\land\; (c_0 \xrightarrow{\sigma,h,t}{}^{*} c).
\]
This exposes scheduler and handler choices to the proof obligations and aligns with the three-dimensional algebra view: horizontal composition is list concatenation of threads, vertical composition is monadic substitution, and spatial composition is mediated by the shared-state merge.

\paragraph{Examples.} Two driver files exercise the machinery: \texttt{ConcSpawn.v} shows that one scheduler step adds a spawned thread; \texttt{ConcChan.v} steps through a send/recv pair with unchanged shared state. They serve as sanity checks rather than full case studies.

\section{Relationship to prior work}
\begin{itemize}[leftmargin=1.5em]
  \item \textbf{Three-dimensional refinement} (\cite{compcertoe}): The reachability-based \(R_{\mathsf{conc}}\) mirrors the algebraic composition across modules, abstraction levels, and state components, leaving scheduler/memory relations parametric.
  \item \textbf{TKMR and cooperative stacks} (\cite{compcertoc}): Handlers are the hook for threaded Kripke memory relations; the next step is to instantiate them with TKMR-like relations and prove preservation under compilation passes.
  \item \textbf{Compositional linearizability} (\cite{ctlinear}): The tensor and configuration merge provide the symmetric monoidal structure needed to connect to Karoubi-envelope reasoning; coherence laws remain to be proved for true parallel composition.
\end{itemize}

\section{Status}
\begin{itemize}[leftmargin=1.5em]
  \item Implemented: \texttt{ConcSignature}, \texttt{ConcMonad} (with sequential tensor and smart constructors/\texttt{do}-notation), \texttt{ConcStrategy} (handlers/scheduler/step), \texttt{ConcRefinement} (reachability-based), examples with concrete handlers and scheduler steps.
  \item Limitations: tensor is sequential; no fairness or scheduler obligations are encoded; handlers are uninterpreted; refinement is reachability-only (no traces or liveness); examples are single-step sanity checks.
  \item Build: Coq~8.15.2, OCaml~4.12.1, \texttt{./configure -nocompcert \&\& make -j4} (CompCert optional on Linux).
\end{itemize}

\section{Next work}
\begin{itemize}[leftmargin=1.5em]
  \item Strengthen \(R_{\mathsf{conc}}\) to trace/step-indexed simulations with fairness assumptions on \(\sigma\); relate to TKMR-style memory relations.
  \item Replace the sequential tensor with a parallel tensor satisfying symmetric monoidal coherence and compatible with Karoubi envelopes; prove associativity/symmetry/unit laws at the configuration level.
  \item Instantiate handlers with TKMR to connect to CompCertOC-style compilation passes and prove preservation for spawn/yield/send/recv/join.
  \item Develop real case studies (e.g., producer/consumer, fork/join pipelines) with compositional refinement theorems and extracted traces.
\end{itemize}

\bibliographystyle{abbrv}
\bibliography{references}

\end{document}

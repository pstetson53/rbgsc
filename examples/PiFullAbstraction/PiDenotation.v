(** * RBGS-native denotational model
    This file connects the pi-calculus fragment to RBGS infrastructure.
    We model actions as an RBGS effect signature (using
    [models.EffectSignatures] / [structures.Effects]) and interpret
    processes as interaction specifications ([models.IntSpec]) living in
    the free completely distributive lattice ([lattices.FCD]).

    The design mirrors the monadic metalanguage interpretation in
    Fiore-Moggi-Sangiorgi Sections 4-6: channel interactions become effects,
    and process combinators are mapped to RBGS combinators (bind,
    joins, bottom). *)

From Coq Require Import Bool.Bool Arith.PeanoNat.
Require Import FunctionalExtensionality.
Require Import models.EffectSignatures.
Require Import models.IntSpec.
Require Import lattices.FCD.
Require Import structures.Lattice.
Require Import structures.Effects.
Require Import Program.
Require Import Coq.Arith.Arith.
Require Import Coq.micromega.Lia.
Require Import Coq.Program.Wf.
Require Import Recdef.
Require Import examples.PiFullAbstraction.PiSyntax.
Require Import examples.PiFullAbstraction.PiOperational.

Import ISpec.

Notation "x >>= f" := (ISpec.bind f x)
  (at level 40, left associativity).
Notation "v <- x ; M" := (x >>= fun v => M)
  (at level 65, right associativity).

(** ** Effect signature for pi actions *)

Inductive pi_sig : esig :=
| sig_tau : pi_sig unit
| sig_out : name -> name -> pi_sig unit
| sig_in  : name -> pi_sig name.

(** This converts the dependent [pi_sig] into the algebraic signature
    used elsewhere in RBGS (via [models.EffectSignatures]). *)
Definition pi_signature : SigBase.sig := SigBase.esig_sig pi_sig.

(** ** Connecting operational labels to signature operations *)

Definition op_of_action (a : action) : pi_sig (match a with
                                              | ActTau => unit
                                              | ActOut _ _ => unit
                                              | ActIn _ _ => name
                                              end) :=
  match a with
  | ActTau => sig_tau
  | ActOut c d => sig_out c d
  | ActIn c _ => sig_in c
  end.

(** ** Denotational semantics *)

Lemma size_tau p : proc_size p < proc_size (PTau p). Proof. cbn; lia. Qed.
Lemma size_out p a b : proc_size p < proc_size (POut a b p). Proof. cbn; lia. Qed.
Lemma size_nu p x : proc_size p < proc_size (PNu x p). Proof. cbn; lia. Qed.
Lemma size_match p a b : proc_size p < proc_size (PMatch a b p). Proof. cbn; lia. Qed.
Lemma size_rep p : proc_size p < proc_size (PRep p). Proof. cbn; lia. Qed.

(** Finite unrolling for replication: [unroll_rep n p] spawns [n] copies of [p]
    in parallel.  This is used to give a finitary denotation to replication,
    matching the finite fragment required by FMS Theorem 6.4. *)
Fixpoint unroll_rep (n : nat) (p : proc) : proc :=
  match n with
  | O => PZero
  | S n' => PPar p (unroll_rep n' p)
  end.

(** Communication steps inside parallel composition. *)
Inductive comm_step (p q : proc) : proc -> Prop :=
| CommStepL a b x p' q' :
    step (ActOut a b) p p' ->
    step (ActIn a x) q q' ->
    comm_step p q (PPar p' (PiSyntax.subst x b q'))
| CommStepR a b x p' q' :
    step (ActIn a x) p p' ->
    step (ActOut a b) q q' ->
    comm_step p q (PPar (PiSyntax.subst x b p') q').

Fixpoint denote_fuel (fuel : nat) (p : proc) : ispec pi_sig unit :=
  match fuel with
  | O => bot
  | S fuel' =>
      match p with
      | PZero => ret tt
      | PTau p' =>
          _ <- int sig_tau; denote_fuel fuel' p'
      | POut a b p' =>
          _ <- int (sig_out a b); denote_fuel fuel' p'
      | PIn a x p' =>
          ISpec.bind (fun v => denote_fuel fuel' (PiSyntax.subst x v p')) (int (sig_in a))
      | PPar p q =>
          (* Interleaving plus synchronization on matching in/out actions. *)
          denote_fuel fuel' p ||
          denote_fuel fuel' q ||
          sup r : {r : proc | comm_step p q r},
            _ <- int sig_tau; denote_fuel fuel' (proj1_sig r)
      | PSum p q =>
          (* External choice corresponds to join in the free CDL. *)
          denote_fuel fuel' p || denote_fuel fuel' q
      | PNu x p' =>
          denote_fuel fuel' p'
      | PMatch a b p' =>
          if Nat.eqb a b then denote_fuel fuel' p' else bot
      | PRep p' =>
          (* Replication is interpreted by unrolling a finite number of copies.
             This suffices for the finite fragment and for approximants used in
             the general domain-theoretic model. *)
          denote_fuel fuel' (unroll_rep fuel' p')
      end
  end.

Definition denote (p : proc) : ispec pi_sig unit :=
  denote_fuel (proc_size p) p.

(** ** Parallel adequacy lemmas (soundness)
    The parallel denotation includes left/right interleavings and internal
    synchronizations generated by [comm_step]. *)

Lemma denote_par_left_sound :
  forall n p q,
    denote_fuel n p [= denote_fuel (S n) (PPar p q).
Proof.
  intros n p q. cbn.
  etransitivity.
  - apply join_ub_l.
  - apply join_ub_l.
Qed.

Lemma denote_par_right_sound :
  forall n p q,
    denote_fuel n q [= denote_fuel (S n) (PPar p q).
Proof.
  intros n p q. cbn.
  etransitivity.
  - apply join_ub_r.
  - apply join_ub_l.
Qed.

Lemma denote_comm_sound :
  forall n p q r,
    comm_step p q r ->
    (_ <- int sig_tau; denote_fuel n r) [= denote_fuel (S n) (PPar p q).
Proof.
  intros n p q r Hcomm. cbn.
  etransitivity.
  - change (_ <- int sig_tau; denote_fuel n r) with
        ((fun r0 : {r : proc | comm_step p q r} =>
            _ <- int sig_tau; denote_fuel n (proj1_sig r0))
           (exist _ r Hcomm)).
    apply (sup_ub (exist _ r Hcomm)).
  - apply join_ub_r.
Qed.

(** ** Prefix adequacy
    For guarded prefixes (tau/out/in), the denotation follows the operational
    step exactly.  Contextual rules (par/comm/sum/nu/match/rep) are handled
    compositionally by the recursive structure of [denote_fuel]; this lemma
    isolates the direct correspondence for the primitive prefixes. *)

Lemma denote_step_sound_prefix :
  forall act p p',
    step act p p' ->
    match act, p with
    | ActTau, PTau r =>
        p' = r /\ denote p = int sig_tau >>= fun _ => denote r
    | ActOut a b, POut a' b' r =>
        a = a' /\ b = b' /\ p' = r /\
        denote p = int (sig_out a b) >>= fun _ => denote r
    | ActIn a x, PIn a' x' r =>
        a = a' /\ x = x' /\ p' = r /\
        denote p = ISpec.bind (fun v => denote (PiSyntax.subst x v r)) (int (sig_in a))
    | _, _ => True
    end.
Proof.
Admitted.

Lemma denote_step_complete_prefix :
  forall act p,
    (exists r, p = PTau r /\ act = ActTau) \/
    (exists a b r, p = POut a b r /\ act = ActOut a b) \/
    (exists a x r, p = PIn a x r /\ act = ActIn a x) ->
    exists p', step act p p'.
Proof.
  intros act p H.
  destruct H as [[r [Hp Ha]]|H]; subst.
  - exists r. constructor.
  - destruct H as [[a [b [r [Hp Ha]]]]|H]; subst.
    + exists r. constructor.
    + destruct H as [a [x [r [Hp Ha]]]]; subst.
      exists r. constructor.
Qed.
